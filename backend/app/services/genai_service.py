from typing import Optional, Dict, Any
import logging
import time
import requests
from app.models.cohort import (
    NaturalLanguageQuery, NaturalLanguageResponse, 
    CohortDefinition, CriteriaDefinition, CriteriaType
)
from app.services.omop_service import omop_service
from app.services.cohort_builder import cohort_builder
from app.db.databricks import db
from app.config import settings

logger = logging.getLogger(__name__)


class GenAIService:
    """
    Service for processing natural language queries using Databricks Genie API.
    
    Uses the Genie Conversation API to process natural language queries
    and convert them into SQL queries against OMOP data.
    """
    
    def __init__(self):
        self.schema = settings.omop_full_schema
        self.genie_space_id = settings.databricks_genie_space_id
        self.databricks_host = settings.databricks_host
        self.databricks_token = settings.databricks_token
        self.api_base_url = f"https://{self.databricks_host}/api/2.0/genie"
    
    def process_natural_language_query(self, nl_query: NaturalLanguageQuery) -> NaturalLanguageResponse:
        """
        Process a natural language query using Databricks Genie API.
        
        This uses the Genie Conversation API to:
        1. Start a conversation with the Genie Space
        2. Poll for the generated SQL response
        3. Execute the SQL to get patient counts
        4. Return structured results
        """
        
        if not self.genie_space_id:
            logger.warning("Genie Space ID not configured. Set DATABRICKS_GENIE_SPACE_ID environment variable to enable AI-powered natural language queries.")
            logger.info("Falling back to rule-based pattern matching approach")
            return self._fallback_rule_based_query(nl_query)
        
        try:
            # Step 1: Start a conversation with Genie
            conversation_data = self._start_genie_conversation(nl_query.query)
            
            if not conversation_data:
                logger.error("Failed to start Genie conversation. Falling back to rule-based pattern matching.")
                logger.info("To use Genie AI, verify: 1) Genie Space ID is correct, 2) Token has permission, 3) Space exists in workspace")
                return self._fallback_rule_based_query(nl_query)
            
            conversation_id = conversation_data['conversation']['id']
            message_id = conversation_data['message']['id']
            
            # Step 2: Poll for the message to complete
            message_result = self._poll_message_status(conversation_id, message_id)
            
            if not message_result or message_result.get('status') != 'COMPLETED':
                logger.error(f"Genie message did not complete successfully: {message_result.get('status')}")
                return self._fallback_rule_based_query(nl_query)
            
            # Step 3: Extract SQL and explanation from attachments
            sql_generated = ""
            explanation = message_result.get('attachments', [{}])[0].get('query', {}).get('query', "") if message_result.get('attachments') else ""
            genie_text = message_result.get('attachments', [{}])[0].get('text', {}).get('content', "") if message_result.get('attachments') else ""
            
            if not sql_generated:
                sql_generated = explanation
            
            # Step 4: Try to execute the SQL to get results
            result_count = 0
            query_results = None
            try:
                if sql_generated:
                    # Execute the Genie-generated SQL
                    results = db.execute_query(sql_generated)
                    result_count = len(results) if results else 0
                    query_results = results  # Store the actual results
            except Exception as e:
                logger.warning(f"Could not execute Genie-generated SQL: {e}")
            
            # Create a cohort definition placeholder (Genie provides SQL directly)
            cohort_def = CohortDefinition(
                name=f"Genie Query: {nl_query.query[:50]}",
                description=f"Generated by Databricks Genie from: {nl_query.query}"
            )
            
            explanation_text = genie_text if genie_text else f"Genie generated SQL query for: {nl_query.query}"
            
            return NaturalLanguageResponse(
                query=nl_query.query,
                sql_generated=sql_generated,
                cohort_definition=cohort_def,
                result_count=result_count,
                explanation=explanation_text,
                query_results=query_results
            )
            
        except Exception as e:
            logger.error(f"Error processing Genie query: {e}", exc_info=True)
            return self._fallback_rule_based_query(nl_query)
    
    def _start_genie_conversation(self, question: str) -> Optional[Dict[str, Any]]:
        """
        Start a new Genie conversation.
        
        POST /api/2.0/genie/spaces/{space_id}/start-conversation
        """
        url = f"{self.api_base_url}/spaces/{self.genie_space_id}/start-conversation"
        
        headers = {
            "Authorization": f"Bearer {self.databricks_token}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "content": question
        }
        
        try:
            # Use SSL verification setting (note: original code had this inverted for corporate proxy compatibility)
            response = requests.post(url, json=payload, headers=headers, verify=settings.databricks_verify_ssl)
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as e:
            if e.response.status_code == 404:
                logger.error(f"Genie Space not found. Please verify the Genie Space ID '{self.genie_space_id}' exists and is accessible.")
                logger.error(f"URL attempted: {url}")
            elif e.response.status_code == 403:
                logger.error(f"Access denied to Genie Space. Check token permissions for Space ID '{self.genie_space_id}'")
            else:
                logger.error(f"HTTP error starting Genie conversation: {e}")
            return None
        except requests.exceptions.RequestException as e:
            logger.error(f"Error starting Genie conversation: {e}")
            logger.error(f"If you see SSL errors, try setting DATABRICKS_VERIFY_SSL=false in your .env file")
            return None
    
    def _poll_message_status(self, conversation_id: str, message_id: str, max_wait_seconds: int = 120) -> Optional[Dict[str, Any]]:
        """
        Poll for message completion status.
        
        GET /api/2.0/genie/spaces/{space_id}/conversations/{conversation_id}/messages/{message_id}
        """
        url = f"{self.api_base_url}/spaces/{self.genie_space_id}/conversations/{conversation_id}/messages/{message_id}"
        
        headers = {
            "Authorization": f"Bearer {self.databricks_token}"
        }
        
        start_time = time.time()
        poll_interval = 2  # Start with 2 seconds
        max_poll_interval = 10  # Cap at 10 seconds
        
        while time.time() - start_time < max_wait_seconds:
            try:
                # Use SSL verification setting (matches databricks.py behavior)
                response = requests.get(url, headers=headers, verify=settings.databricks_verify_ssl)
                response.raise_for_status()
                message_data = response.json()
                
                status = message_data.get('status')
                logger.info(f"Genie message status: {status}")
                
                if status in ['COMPLETED', 'FAILED', 'CANCELLED']:
                    return message_data
                
                # Wait before polling again
                time.sleep(poll_interval)
                
                # Exponential backoff, but cap at max_poll_interval
                poll_interval = min(poll_interval * 1.5, max_poll_interval)
                
            except requests.exceptions.RequestException as e:
                logger.error(f"Error polling Genie message: {e}")
                logger.error(f"If you see SSL errors, try setting DATABRICKS_VERIFY_SSL=false in your .env file")
                return None
        
        logger.warning(f"Genie message polling timed out after {max_wait_seconds} seconds")
        return None
    
    def _fallback_rule_based_query(self, nl_query: NaturalLanguageQuery) -> NaturalLanguageResponse:
        """
        Fallback to simple rule-based approach when Genie is not available.
        
        This is the original implementation using pattern matching.
        """
        query = nl_query.query.lower()
        
        # Simple pattern matching for demonstration
        cohort_def = CohortDefinition(
            name=f"NL Query: {nl_query.query[:50]}",
            description=f"Generated from natural language query: {nl_query.query}"
        )
        
        # Extract conditions (diabetes, hypertension, etc.)
        conditions = self._extract_medical_terms(query, "condition")
        if conditions:
            for condition_name in conditions:
                concepts = omop_service.search_concepts(
                    condition_name, 
                    domain_id="Condition",
                    limit=5
                )
                if concepts:
                    criteria = CriteriaDefinition(
                        id=f"condition_{len(cohort_def.inclusion_criteria)}",
                        criteria_type=CriteriaType.CONDITION,
                        concept_ids=[c.concept_id for c in concepts[:3]],
                        concept_names=[c.concept_name for c in concepts[:3]]
                    )
                    cohort_def.inclusion_criteria.append(criteria)
        
        # Extract drugs (metformin, aspirin, etc.)
        drugs = self._extract_medical_terms(query, "drug")
        if drugs:
            for drug_name in drugs:
                concepts = omop_service.search_concepts(
                    drug_name,
                    domain_id="Drug",
                    limit=5
                )
                if concepts:
                    criteria = CriteriaDefinition(
                        id=f"drug_{len(cohort_def.inclusion_criteria)}",
                        criteria_type=CriteriaType.DRUG,
                        concept_ids=[c.concept_id for c in concepts[:3]],
                        concept_names=[c.concept_name for c in concepts[:3]]
                    )
                    cohort_def.inclusion_criteria.append(criteria)
        
        # Extract procedures
        procedures = self._extract_medical_terms(query, "procedure")
        if procedures:
            for procedure_name in procedures:
                concepts = omop_service.search_concepts(
                    procedure_name,
                    domain_id="Procedure",
                    limit=5
                )
                if concepts:
                    criteria = CriteriaDefinition(
                        id=f"procedure_{len(cohort_def.inclusion_criteria)}",
                        criteria_type=CriteriaType.PROCEDURE,
                        concept_ids=[c.concept_id for c in concepts[:3]],
                        concept_names=[c.concept_name for c in concepts[:3]]
                    )
                    cohort_def.inclusion_criteria.append(criteria)
        
        # Build SQL and execute cohort
        sql = cohort_builder._build_cohort_sql(cohort_def) if cohort_def.inclusion_criteria else ""
        
        # Execute to get count and results
        result_count = 0
        query_results = None
        try:
            if cohort_def.inclusion_criteria:
                result = cohort_builder.build_cohort(cohort_def)
                result_count = result.patient_count
                # Try to get actual results from the SQL query
                if sql:
                    try:
                        query_results = db.execute_query(sql)
                    except Exception as e:
                        logger.warning(f"Could not retrieve query results: {e}")
        except Exception as e:
            logger.error(f"Error executing cohort: {e}")
        
        explanation = self._generate_explanation(cohort_def, query)
        
        return NaturalLanguageResponse(
            query=nl_query.query,
            sql_generated=sql,
            cohort_definition=cohort_def,
            result_count=result_count,
            explanation=explanation,
            query_results=query_results
        )
    
    def _extract_medical_terms(self, query: str, term_type: str) -> list[str]:
        """
        Extract medical terms from query.
        
        In production, this would use:
        - Named Entity Recognition (NER) models
        - Medical vocabulary matching (UMLS, SNOMED CT)
        - Databricks AI functions for entity extraction
        """
        
        # Common medical condition keywords
        conditions = [
            "diabetes", "hypertension", "heart disease", "asthma", 
            "copd", "cancer", "stroke", "pneumonia", "sepsis",
            "depression", "anxiety", "alzheimer", "dementia"
        ]
        
        # Common drug keywords
        drugs = [
            "metformin", "insulin", "aspirin", "statin", "lisinopril",
            "warfarin", "heparin", "prednisone", "antibiotics",
            "chemotherapy", "ace inhibitor", "beta blocker"
        ]
        
        # Common procedure keywords
        procedures = [
            "surgery", "biopsy", "endoscopy", "colonoscopy",
            "mri", "ct scan", "x-ray", "ultrasound", "ecg", "ekg"
        ]
        
        found_terms = []
        
        if term_type == "condition":
            search_list = conditions
        elif term_type == "drug":
            search_list = drugs
        elif term_type == "procedure":
            search_list = procedures
        else:
            return []
        
        for term in search_list:
            if term in query:
                found_terms.append(term)
        
        return found_terms
    
    def _generate_explanation(self, cohort_def: CohortDefinition, original_query: str) -> str:
        """Generate human-readable explanation of the cohort."""
        
        explanation = f"Based on your query '{original_query}', I created a cohort with:\n\n"
        
        if cohort_def.inclusion_criteria:
            explanation += "Inclusion criteria:\n"
            for i, criteria in enumerate(cohort_def.inclusion_criteria, 1):
                criteria_type = criteria.criteria_type.value.title()
                concept_names = criteria.concept_names or ["Unknown"]
                explanation += f"{i}. {criteria_type}: {', '.join(concept_names)}\n"
        
        if cohort_def.exclusion_criteria:
            explanation += "\nExclusion criteria:\n"
            for i, criteria in enumerate(cohort_def.exclusion_criteria, 1):
                criteria_type = criteria.criteria_type.value.title()
                concept_names = criteria.concept_names or ["Unknown"]
                explanation += f"{i}. {criteria_type}: {', '.join(concept_names)}\n"
        
        if not cohort_def.inclusion_criteria and not cohort_def.exclusion_criteria:
            explanation += "No specific criteria could be extracted from your query. Try being more specific about conditions, drugs, or procedures."
        
        return explanation


genai_service = GenAIService()

